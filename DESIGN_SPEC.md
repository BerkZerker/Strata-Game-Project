# Project Design Spec: 2D High-Resolution Procedural Terrain

## 1. Overview

This document outlines the technical design for creating a 2D high-resolution, destructible, voxel-style sandbox game, inspired by titles like _Terraria_ and _KYORA_. The core of this design moves away from traditional `TileMap` systems to a more flexible and performant procedural mesh-based approach, allowing for near-pixel-level detail and smooth, organic terrain.

## 2. Core Architecture: Procedural Meshes

The foundation of the terrain system will be procedurally generated meshes, not `TileMap` nodes.

- **Why?** `TileMap` is excellent for grid-based games but becomes a performance bottleneck when dealing with millions of tiny "tiles" (i.e., pixels). Generating a single, optimized mesh for the visible terrain surface is significantly more performant.
- **Benefits:**
  - **Performance:** Drastically reduces draw calls and node count.
  - **Flexibility:** Allows for smooth, non-grid-aligned terrain features.
  - **Aesthetics:** Enables advanced visual effects like smooth texture blending.

## 3. World Structure

### 3.1. Chunking

The world will be infinite (or very large) and therefore must be broken into manageable **chunks**.

- **Chunk:** A fixed-size square of the world (e.g., 64x64 squares).
- **Loading/Unloading:** Only chunks within a certain radius of the player will be active (loaded into memory, rendered, and simulated). Chunks outside this radius will be unloaded to conserve resources.
- **Threading:** The generation of new chunk data should be offloaded to a separate `Thread` to prevent the game from freezing or stuttering as the player explores.

### 3.2. Data Representation

Each chunk's terrain will be stored in a 2D array. This grid is the "source of truth" for the entire system.

- **Data per Cell:** Each cell in the grid can store multiple pieces of information, such as:
  - `density`: A float value (e.g., 0.0 to 1.0) generated by a noise function, determining if the cell is solid or empty.
  - `material_type`: An integer or enum representing the material (e.g., `DIRT`, `STONE`, `AIR`).

## 4. Terrain Generation & Rendering

### 4.1. Visual Mesh (`MeshInstance2D`)

Each chunk will have a `MeshInstance2D` node to render its main terrain.

1.  **Noise Generation:** Use a noise algorithm like `FastNoiseLite` (built into Godot 4) to generate the `density` values for the chunk's data grid. Layering multiple noise functions can create more interesting features like caves, overhangs, and biomes.
2.  **Mesh Creation (`SurfaceTool`):** The **Marching Squares** algorithm will be used to generate the visual mesh. It iterates through the data grid and, for each 2x2 group of cells, creates the appropriate triangles to form a surface along the `density` threshold (e.g., 0.5).
3.  **Texturing (Texture Atlas & UV Mapping):**
    - A **Texture Atlas** (a single image containing multiple textures) will be used for all primary terrain materials (dirt, stone, grass, etc.).
    - When generating the mesh, the `SurfaceTool` will be used to set the **UV coordinates** for each vertex. The UVs will map to the correct texture within the atlas based on the `material_type` from the data grid. This allows a single mesh and a single material to render all terrain types efficiently.

### 4.2. Details (`MultiMeshInstance2D`)

For small, frequently repeated objects, `MultiMeshInstance2D` will be used to maintain performance.

- **Use Cases:** Ores, small plants, pebbles, grass tufts.
- **Process:** After generating the main terrain, scan the data grid for locations to place these details. Add the transform of each detail to a `MultiMeshInstance2D`, which will render all of them in a single draw call.

## 5. Physics & Collision

### 5.1. Static Terrain (`StaticBody2D`)

Each chunk will have a single `StaticBody2D` node to handle all its static terrain collision. This node will act as a **container for multiple collision shapes**.

1.  **Collision Generation (Marching Squares):** The same Marching Squares algorithm used for the visual mesh will also be used to find the outlines of solid terrain.
2.  **Implementation:**
    - The algorithm will produce a list of one or more closed-loop polygon outlines.
    - **Crucially, do not attempt to merge these outlines.** This is error-prone and unnecessary.
    - For **each** polygon outline generated, create a new `CollisionPolygon2D` node and add it as a child to the chunk's `StaticBody2D`.
3.  **Result:** This approach naturally handles all complex cases:
    - **Solid chunks with holes:** Will result in two `CollisionPolygon2D` children (one for the outer boundary, one for the inner hole).
    - **Chunks with multiple separate "islands":** Will result in multiple `CollisionPolygon2D` children, one for each island.

## 6. Dynamic Systems (Cellular Automata)

Systems like liquids and falling sand will **not** use individual physics nodes per particle. They will be simulated directly within the data grid for maximum performance.

- **Logic:** A simple set of rules is applied to each relevant cell every physics frame.
  - **Liquids:** 1. Try to move down. 2. If blocked, try to move down-and-sideways. 3. If blocked, try to spread sideways.
  - **Falling Sand:** 1. Try to move down. 2. If blocked, try to move down-and-sideways to form a pile.
- **Rendering:** The results of the simulation are then used to generate or update a separate visual mesh (e.g., a `MeshInstance2D` for the water surface).
- **Interaction:** Use `Area2D` nodes to detect when the player or other entities enter these simulated areas to apply effects (e.g., buoyancy, damage).

## 7. Visual Polish (Shaders)

Shaders will be used to elevate the visual quality beyond simple textures.

- **Smooth Texture Blending:** A shader can be used on the terrain material to smoothly blend the textures between different material types (e.g., where dirt meets stone), avoiding a hard, blocky look.
- **Lighting & Depth:** Implement custom 2D lighting effects, such as a soft ambient occlusion in corners and crevices to give the terrain a sense of depth.
- **Liquid Effects:** Create animated effects for liquids, such as ripples, caustics, and screen distortion when the camera is submerged.

## 8. Sample Scene Structure (Chunk)

A typical `chunk.tscn` would look like this:

```
- Chunk (Node2D)
  - TerrainMesh (MeshInstance2D)
  - TerrainCollision (StaticBody2D)
    - CollisionPolygon2D
    - CollisionPolygon2D
    - ... (more polygons as needed)
  - LiquidMesh (MeshInstance2D)
  - LiquidInteractionArea (Area2D)
    - CollisionShape2D
  - OreDetails (MultiMeshInstance2D)
  - FloraDetails (MultiMeshInstance2D)
```
